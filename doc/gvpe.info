This is gvpe.info, produced by makeinfo version 4.13 from gvpe.texi.

INFO-DIR-SECTION Networking tools
START-INFO-DIR-ENTRY
* gvpe: (gvpe).              The GNU VPE Manual.
END-INFO-DIR-ENTRY

   This is the info manual for vpe, the Virtual Private Ethernet daemon.

   Copyright (C) 2003-2008 Marc Lehmann <gvpe@schmorp.de>.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.


File: gvpe.info,  Node: Top,  Next: Overview,  Up: (dir)

1 Introduction
**************

This is the documentation for the GNU Virtual Private Ethernet suite.

   The GNU Virtual Private Ethernet suite implements a virtual (uses
udp, tcp, rawip and other protocols for tunneling), private (encrypted,
authenticated) ethernet (mac-based, broadcast-based network) that is
shared among multiple nodes, in effect implementing an ethernet bus
over public networks.

* Menu:

* Overview::        Introduction to and Tutorial for GVPE (gvpe(5))
* OS Dependencies:: OS-Dependent Installation and Configuration Notes (gvpe.osdep(5))
* gvpe.conf::       The main configuration file (gvpe.conf(5))
* gvpectrl::        Configuration/Control Program Reference (gvpectrl(8))
* gvpe::            The GVPE Daemon (gvpe(8))
* gvpe.protocol::   The GVPE Transport and VPN Protocols (gvpe.protocol(7))
* Simple Example::  A simple yet realistic Example
* Complex Example:: A non-trivial Example
* Index::           Keyword and Concept index


File: gvpe.info,  Node: Overview,  Next: OS Dependencies,  Prev: Top,  Up: Top

2 Overview
**********

2.1 NAME
========

GNU-VPE - Overview of the GNU Virtual Private Ethernet suite.

2.2 DESCRIPTION
===============

GVPE is a suite designed to provide a virtual private network for
multiple nodes over an untrusted network. This document first gives an
introduction to VPNs in general and then describes the specific
implementation of GVPE.

2.2.1 WHAT IS A VPN?
--------------------

VPN is an acronym, it stands for:

   * Virtual

     Virtual means that no physical network is created (of course), but
     a network is _emulated_ by creating multiple tunnels between the
     member nodes by encapsulating and sending data over another
     transport network.

     Usually the emulated network is a normal IP or Ethernet, and the
     transport network is the Internet. However, using a VPN system
     like GVPE to connect nodes over other untrusted networks such as
     Wireless LAN is not uncommon.

   * Private

     Private means that non-participating nodes cannot decode ("sniff)"
     nor inject ("spoof") packets. This means that nodes can be
     connected over untrusted networks such as the public Internet
     without fear of being eavesdropped while at the same time being
     able to trust data sent by other nodes.

     In the case of GVPE, even participating nodes cannot sniff packets
     send to other nodes or spoof packets as if sent from other nodes,
     so communications between any two nodes is private to those two
     nodes.

   * Network

     Network means that more than two parties can participate in the
     network, so for instance it's possible to connect multiple
     branches of a company into a single network. Many so-called "VPN"
     solutions only create point-to-point tunnels, which in turn can be
     used to build larger networks.

     GVPE provides a true multi-point network in which any number of
     nodes (at least a few dozen in practise, the theoretical limit is
     4095 nodes) can participate.


2.2.2 GVPE DESIGN GOALS
-----------------------

   * SIMPLE DESIGN

     Cipher, HMAC algorithms and other key parameters must be selected
     at compile time - this makes it possible to only link in
     algorithms you actually need. It also makes the crypto part of the
     source very transparent and easy to inspect, and last not least
     this makes it possible to hardcode the layout of all packets into
     the binary. GVPE goes a step further and internally reserves
     blocks of the same length for all packets, which virtually removes
     all possibilities of buffer overflows, as there is only a single
     type of buffer and it's always of fixed length.

   * EASY TO SETUP

     A few lines of config (the config file is shared unmodified
     between all hosts) and a single run of gvpectrl to generate the
     keys suffices to make it work.

   * MAC-BASED SECURITY

     Since every host has it's own private key, other hosts cannot
     spoof traffic from this host. That makes it possible to filter
     packet by MAC address, e.g. to ensure that packets from a specific
     IP address come, in fact, from a specific host that is associated
     with that IP and not from another host.


2.3 PROGRAMS
============

Gvpe comes with two programs: one daemon (gvpe) and one control program
(gvpectrl).

   * gvpectrl

     This program is used to generate the keys, check and give an
     overview of of the configuration and to control the daemon
     (restarting etc.).

   * gvpe

     This is the daemon used to establish and maintain connections to
     the other network nodes. It should be run on the gateway of each
     VPN subnet.


2.4 COMPILETIME CONFIGURATION
=============================

Please have a look at the gvpe.osdep(5) manpage for platform-specific
information.

   Gvpe hardcodes most encryption parameters. While this reduces
flexibility, it makes the program much simpler and helps making buffer
overflows impossible under most circumstances.

   Here are a few recipes for compiling your gvpe, showing the extremes
(fast, small, insecure OR slow, large, more secure), between which you
should choose:

2.4.1 AS LOW PACKET OVERHEAD AS POSSIBLE
----------------------------------------

        ./configure --enable-hmac-length=4 --enable-rand-length=0

   Minimize the header overhead of VPN packets (the above will result
in only 4 bytes of overhead over the raw ethernet frame). This is a
insecure configuration because a HMAC length of 4 makes collision
attacks based on the birthday paradox pretty easy.

2.4.2 MINIMIZE CPU TIME REQUIRED
--------------------------------

        ./configure --enable-cipher=bf --enable-digest=md4

   Use the fastest cipher and digest algorithms currently available in
gvpe. MD4 has been broken and is quite insecure, though, so using
another digest algorithm is recommended.

2.4.3 MAXIMIZE SECURITY
-----------------------

        ./configure --enable-hmac-length=16 --enable-rand-length=8 --enable-digest=sha1

   This uses a 16 byte HMAC checksum to authenticate packets (I guess
8-12 would also be pretty secure ;) and will additionally prefix each
packet with 8 bytes of random data. In the long run, people should move
to SHA-256 and beyond).

   In general, remember that AES-128 seems to be as secure but faster
than AES-192 or AES-256, more randomness helps against sniffing and a
longer HMAC helps against spoofing. MD4 is a fast digest, SHA1,
RIPEMD160, SHA256 are consecutively better, and Blowfish is a fast
cipher (and also quite secure).

2.5 HOW TO SET UP A SIMPLE VPN
==============================

In this section I will describe how to get a simple VPN consisting of
three hosts up and running.

2.5.1 STEP 1: configuration
---------------------------

First you have to create a daemon configuration file and put it into
the configuration directory. This is usually /etc/gvpe, depending on
how you configured gvpe, and can be overwritten using the -c command
line switch.

   Put the following lines into /etc/gvpe/gvpe.conf:

        udp-port = 50000 # the external port to listen on (configure your firewall)
        mtu = 1400       # minimum MTU of all outgoing interfaces on all hosts
        ifname = vpn0    # the local network device name

        node = first     # just a nickname
        hostname = first.example.net # the DNS name or IP address of the host

        node = second
        hostname = 133.55.82.9

        node = third
        hostname = third.example.net

   The only other file necessary is the if-up script that initializes
the virtual ethernet interface on the local host. Put the following
lines into /etc/gvpe/if-up and make it executable (chmod 755
/etc/gvpe/if-up):

        #!/bin/sh
        ip link set $IFNAME address $MAC mtu $MTU up
        [ $NODENAME = first  ] && ip addr add 10.0.1.1 dev $IFNAME
        [ $NODENAME = second ] && ip addr add 10.0.2.1 dev $IFNAME
        [ $NODENAME = third  ] && ip addr add 10.0.3.1 dev $IFNAME
        ip route add 10.0.0.0/16 dev $IFNAME

   This script will give each node a different IP address in the
10.0/16 network.  The internal network (if gvpe runs on a router)
should then be set to a subset of that network, e.g.  10.0.1.0/24 on
node first, 10.0.2.0/24 on node second, and so on.

   By enabling routing on the gateway host that runs gvpe all nodes
will be able to reach the other nodes. You can, of course, also use
proxy ARP or other means of pseudo-bridging, or (best) full routing -
the choice is yours.

2.5.2 STEP 2: create the RSA key pairs for all hosts
----------------------------------------------------

Run the following command to generate all key pairs for all nodes (that
might take a while):

        gvpectrl -c /etc/gvpe -g

   This command will put the public keys into
/etc/gvpe/pubkeys/_nodename_ and the private keys into
/etc/gvpe/hostkeys/_nodename_.

2.5.3 STEP 3: distribute the config files to all nodes
------------------------------------------------------

Now distribute the config files and private keys to the other nodes.
This should be done in two steps, since only the private keys meant for
a node should be distributed (so each node has only it's own private
key).

   The example uses rsync-over-ssh

   First all the config files without the hostkeys should be
distributed:

        rsync -avzessh /etc/gvpe first.example.net:/etc/. --exclude hostkeys
        rsync -avzessh /etc/gvpe 133.55.82.9:/etc/. --exclude hostkeys
        rsync -avzessh /etc/gvpe third.example.net:/etc/. --exclude hostkeys

   Then the hostkeys should be copied:

        rsync -avzessh /etc/gvpe/hostkeys/first  first.example.net:/etc/hostkey
        rsync -avzessh /etc/gvpe/hostkeys/second 133.55.82.9:/etc/hostkey
        rsync -avzessh /etc/gvpe/hostkeys/third  third.example.net:/etc/hostkey

   You should now check the configuration by issuing the command
gvpectrl -c /etc/gvpe -s on each node and verify it's output.

2.5.4 STEP 4: starting gvpe
---------------------------

You should then start gvpe on each node by issuing a command like:

        gvpe -D -l info first # first is the nodename

   This will make the gvpe daemon stay in foreground. You should then
see "connection established" messages. If you don't see them check your
firewall and routing (use tcpdump ;).

   If this works you should check your networking setup by pinging
various endpoints.

   To make gvpe run more permanently you can either run it as a daemon
(by starting it without the -D switch), or, much better, from your
inittab or equivalent. I use a line like this on all my systems:

        t1:2345:respawn:/opt/gvpe/sbin/gvpe -D -L first >/dev/null 2>&1

2.5.5 STEP 5: enjoy
-------------------

... and play around. Sending a -HUP (gvpectrl -kHUP) to the daemon will
make it try to connect to all other nodes again. If you run it from
inittab, as is recommended, gvpectrl -k (or simply killall gvpe) will
kill the daemon, start it again, making it read it's configuration
files again.

2.6 COPYRIGHTS AND LICENSES
===========================

GVPE itself is distributed under the GENERAL PUBLIC LICENSE (see the
file COPYING that should be part of your distribution).

   In some configurations it uses modified versions of the tinc vpn
suite, which is also available under the GENERAL PUBLIC LICENSE.


File: gvpe.info,  Node: OS Dependencies,  Next: gvpe.conf,  Prev: Overview,  Up: Top

3 OS Dependencies
*****************

3.1 NAME
========

gvpe.osdep - os dependent information

3.2 DESCRIPTION
===============

This file tries to capture OS-dependent configuration or build issues,
quirks and platform limitations, as known.

3.3 TUN vs. TAP interface
=========================

Most operating systems nowadays support something called a
_tunnel_-device, which makes it possible to divert IPv4 (and often
other protocols, too) into a user space daemon like gvpe. This is being
referred to as a TUN-device.

   This is fine for point-to-point tunnels, but for a virtual ethernet,
an additional ethernet header is needed. This functionality (called a
TAP device here) is only provided by a subset of the configurations.

   On platforms only supporting a TUN-device, gvpe will invoke it's
magical ethernet emulation package, which currently only handles ARP
requests for the IPv4 protocol (but more could be added, bu the tincd
network drivers might need to be modified for this to work). This means
that on those platforms, only IPv4 will be supported.

   Also, since there is no way (currently) to tell gvpe which IP
subnets are found on a specific host, you will either need to hardwire
the MAC address for TUN-style hosts on all networks (and avoid ARP
altogether, which is possible), or you need to send a packet from these
hosts into the vpn network to tell gvpe the local interface address.

3.4 Interface Initialisation
============================

Unless otherwise notes, the network interface will be initialized with
the expected MAC address and correct MTU value. With most interface
drivers, this is done by running /sbin/ifconfig, so make sure that this
command exists.

3.5 Interface Types
===================

3.5.1 native/linux
------------------

TAP-device; already part of the kernel (only 2.4+ supported, but see
tincd/linux). This is the configuration tested best, as gvpe is being
developed on this platform.

   ifname should be set to the name of the network device.

   To hardwire ARP addresses, use iproute2 (arp can do it, too):

       MAC=fe:fd:80:00:00:$(printf "%02x" $NODEID)
       ip neighbour add 10.11.12.13 lladdr $MAC nud permanent dev $IFNAME

3.5.2 tincd/linux
-----------------

TAP-device; already part of the kernel (2.2 only). See native/linux for
more info.

   ifname should be set to the path of a tap device, e.g. /dev/tap0.
The interface will be named accordingly.

3.5.3 native/cygwin
-------------------

TAP-device; The TAP device to be used must either be the CIPE driver
(http://cipe-win32.sourceforge.net/), or (highly recommended) the newer
TAP-Win32 driver bundled with openvpn (http://openvpn.sf.net/). Just
download and run the openvpn installer. The only option you need to
select is the TAP driver.

   ifname should be set to the name of the device, found in the
registry at (no kidding :):

           HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE10318}\<adapterid>\Connection\Name

   The MAC address is dynamically being patched into packets and
ARP-requests, so only IPv4 works with ARP on this platform.

3.5.4 tincd/bsd
---------------

TAP-device, maybe; migth work for many bsd variants.

   This driver is a newer version of the tincd/*bsd drivers. It _might_
provide a TAP device, or might not work at all. You might try this
interface type first, and, if it doesn't work, try one of the
OS-specific drivers.

3.5.5 tincd/freebsd
-------------------

TAP-device; part of the kernel (since 4.x, maybe earlier).

   ifname should be set to the path of a tap device, e.g. /dev/tap0.
The interface will be named accordingly.

   These commands might be helpful examples:

       ifconfig $IFNAME 10.0.0.$NODEID
       route add -net 10.0.0.0 -netmask 255.255.255.0 -interface $IFNAME 10.0.0.$NODEID

3.5.6 tincd/netbsd
------------------

TUN-device; The interface is a point-to-point device. To initialize it,
you currently need to configure it as a point-to-point device, giving
it an address on your vpn (the exact address doesn't matter), like this:

       ifconfig $IFNAME mtu $MTU up
       ifconfig $IFNAME 10.11.12.13 10.55.66.77
       route add -net 10.0.0.0 10.55.66.77 255.0.0.0
       ping -c1 10.55.66.77 # ping once to tell gvpe your gw ip

   The ping is required to tell the ARP emulator inside GVPE the local
IP address.

   ifname should be set to the path of a tun device, e.g. /dev/tun0.
The interface will be named accordingly.

3.5.7 tincd/openbsd
-------------------

TUN-device; already part of the kernel. See tincd/netbsd for more
information.

3.5.8 native/darwin
-------------------

TAP-device;

   The necessary kernel extension can be found here:

       http://www-user.rhrk.uni-kl.de/~nissler/tuntap/

   There are two drivers, the one to use is the "tap" driver. It driver
must be loaded before use, read the docs on how to install it as a
startup item.

   ifname should be set to the path of a tap device, e.g. /dev/tap0.
The interface will be named accordingly.

   These commands might be helpful examples:

       ifconfig $IFNAME 10.0.0.$NODEID
       route add -net 10.0.0.0 -interface $IFNAME 255.255.255.0

3.5.9 tincd/darwin
------------------

TUN-device; See tincd/netbsd for more information. native/darwin is
preferable.

   The necessary kernel extension can be found here:

       http://chrisp.de/en/projects/tunnel.html

   ifname should be set to the path of a tun device, e.g. /dev/tun0.
The interface will be named accordingly.

   The driver must be loaded before use:

       kmodload tunnel

3.5.10 tincd/solaris
--------------------

TUN-device; already part of the kernel(?), or available here:

       http://vtun.sourceforge.net/tun/

   Some precompiled tun drivers might be available here:

       http://www.monkey.org/~dugsong/fragroute/

   The interface MAC and MTU are _NOT_ set up for you. Please try it
out and send me an ifconfig command invocation that does that.

   See tincd/netbsd for more information.

   Completely untested so far.

3.5.11 tincd/mingw
------------------

TAP-device; see native/cygwin for more information.

   The setup is likely to be similar to native/cygwin.

   Completely untested so far.

3.5.12 tincd/raw_socket
-----------------------

TAP-device; purpose unknown and untested, probably binds itself on an
existing ethernet device (given by ifname). It must be down prior to
running the command, and GVPE will try to set it's MAC address and MTU
to the "correct" values.

   Completely untested so far.

3.5.13 tincd/uml_socket
-----------------------

TAP-device; purpose unknown and untested, probably creates a UNIX
datagram socket (path given by ifname) and reads and writes raw
packets, so might be useful in other than UML contexts.

   No network interface is created, and the MAC and MTU must be set as
appropriate on the other side of the socket.  GVPE will exit if the MAC
address doesn't match what it expects.

   Completely untested so far.

3.5.14 tincd/cygwin
-------------------

Known to be broken, use native/cygwin instead.


File: gvpe.info,  Node: gvpe.conf,  Next: gvpectrl,  Prev: OS Dependencies,  Up: Top

4 gvpe.conf
***********

4.1 NAME
========

gvpe.conf - configuration file for the GNU VPE daemon

4.2 SYNOPSIS
============

        # global options for all nodes
        udp-port = 407
        mtu = 1492
        ifname = vpn0

        # first node is named branch1 and is at 1.2.3.4
        node = branch1
        hostname = 1.2.3.4

        # second node uses dns to resolve the address
        node = branch2
        hostname = www.example.net
        udp-port = 500	# this host uses a different udp-port

        # third node has no fixed ip address
        node = branch3
        connect = ondemand

4.3 DESCRIPTION
===============

The gvpe config file consists of a series of lines that contain
variable = value pairs. Empty lines are ignored. Comments start with a
# and extend to the end of the line. They can be used on their own
lines, or after any directives. Whitespace is allowed around the = sign
or after values, but not within the variable names or values themselves.

   The only exception to the above is the "on" directive that can
prefix any name = value setting and will only "execute" it on the named
node, or (if the nodename starts with "!") on all nodes except the
named one.

   For example, set the MTU to 1450 everywhere, loglevel to noise on
branch1, and connect to ondemand everywhere but on branch2:

        mtu = 1450
        on branch1 loglevel = noise
        on !branch2 connect = ondemand

   All settings are applied "in order", that is, later settings of the
same variable overwrite earlier ones.

4.4 ANATOMY OF A CONFIG FILE
============================

Usually, a config file starts with a few global settings (like the UDP
port to listen on), followed by node-specific sections that begin with
a node = nickname line.

   Every node that is part of the network must have a section that
starts with node = nickname. The number and order of the nodes is
important and must be the same on all nodes. It is not uncommon for
node sections to be completely empty - if the default values are right.

   Node-specific settings can be used at any time. If used before the
first node section they will set the default values for all following
nodes.

4.5 CONFIG VARIABLES
====================

4.5.1 GLOBAL SETTINGS
---------------------

Global settings will affect the behaviour of the running gvpe daemon,
that is, they are in some sense node-specific (config files can set
different values on different nodes using on), but will affect the
behaviour of the gvpe daemon and all connections it creates.

   * dns-forw-host = hostname/ip

     The DNS server to forward DNS requests to for the DNS tunnel
     protocol (default: 127.0.0.1, changing it is highly recommended).

   * dns-forw-port = port-number

     The port where the dns-forw-host is to be contacted (default: 53,
     which is fine in most cases).

   * dns-max-outstanding = integer-number-of-requests

     The maximum number of outstanding DNS transport requests (default:
     100). GVPE will never issue more requests then the given limit
     without receiving replies. In heavily overloaded situations it
     might help to set this to a low number (e.g. 3 or even 1) to limit
     the number of parallel requests.

     The default should be working OK for most links.

   * dns-overlap-factor = float

     The DNS transport uses the minimum request latency (*min_latency*)
     seen during a connection as it's timing base. This factor
     (default: 0.5, must be > 0) is multiplied by *min_latency* to get
     the maximum sending rate (= minimum send interval), i.e. a factor
     of 1 means that a new request might be generated every
     *min_latency* seconds, which means on average there should only
     ever be one outstanding request.  A factor of 0.5 means that GVPE
     will send requests twice as often as the minimum latency measured.

     For congested or picky DNS forwarders you could use a value nearer
     to or exceeding 1.

     The default should be working OK for most links.

   * dns-send-interval = send-interval-in-seconds

     The minimum send interval (= maximum rate) that the DNS transport
     will use to send new DNS requests. GVPE will not exceed this rate
     even when the latency is very low. The default is 0.01, which
     means GVPE will not send more than 100 DNS requests per connection
     per second. For high-bandwidth links you could go lower, e.g. to
     0.001 or so. For congested or rate-limited links, you might want
     to go higher, say 0.1, 0.2 or even higher.

     The default should be working OK for most links.

   * dns-timeout-factor = float

     Factor to multiply the min_latency (see dns-overlap-factor) by to
     get request timeouts. The default of 8 means that the DNS
     transport will resend the request when no reply has been received
     for longer than eight times the minimum (= expected) latency,
     assuming the request or reply has been lost.

     For congested links a higher value might be necessary (e.g. 30).
     If the link is very stable lower values (e.g. 2) might work
     nicely. Values near or below 1 makes no sense whatsoever.

     The default should be working OK for most links but will result in
     low throughput if packet loss is high.

   * if-up = relative-or-absolute-path

     Sets the path of a script that should be called immediately after
     the network interface is initialized (but not necessarily up). The
     following environment variables are passed to it (the values are
     just examples).

     Variables that have the same value on all nodes:

        * CONFBASE=/etc/gvpe

          The configuration base directory.

        * IFNAME=vpn0

          The network interface to initialize.

        * IFTYPE=native # or tincd

        * IFSUBTYPE=linux # or freebsd, darwin etc..

          The interface type (native or tincd) and the subtype (usually
          the OS name in lowercase) that this GVPE was configured for.
          Can be used to select the correct syntax to use for
          network-related commands.

        * MTU=1436

          The MTU to set the interface to. You can use lower values (if
          done consistently on all nodes), but this is usually either
          inefficient or simply ineffective.

        * NODES=5

          The number of nodes in this GVPE network.


     Variables that are node-specific and with values pertaining to the
     node running this GVPE:

        * IFUPDATA=string

          The value of the configuration directive if-up-data.

        * MAC=fe:fd:80:00:00:01

          The MAC address the network interface has to use.

          Might be used to initialize interfaces on platforms where
          GVPE does not do this automatically.  Please see the
          gvpe.osdep(5) man page for platform-specific information.

        * NODENAME=branch1

          The nickname of the node.

        * NODEID=1

          The numerical node ID of the node running this instance of
          GVPE. The first node mentioned in the config file gets ID 1,
          the second ID 2 and so on.


     In addition, all node-specific variables (except NODEID) will be
     available with a postfix of _nodeid, which contains the value for
     that node, e.g. the MAC_1 variable contains the MAC address of
     node #1, while the NODENAME_22 variable contains the name of node
     #22.

     Here is a simple if-up script:

             #!/bin/sh
             ip link set $IFNAME up
             [ $NODENAME = branch1 ] && ip addr add 10.0.0.1 dev $IFNAME
             [ $NODENAME = branch2 ] && ip addr add 10.1.0.1 dev $IFNAME
             ip route add 10.0.0.0/8 dev $IFNAME

     More complicated examples (using routing to reduce ARP traffic)
     can be found in the `etc/' subdirectory of the distribution.

   * ifname = devname

     Sets the tun interface name to the given name. The default is
     OS-specific and most probably something like tun0.

   * ifpersist = yes|true|on | no|false|off

     Should the tun/tap device be made persistent, that is, should the
     device stay up even when gvpe exits? Some versions of the tunnel
     device have problems sending packets when gvpe is restarted in
     persistent mode, so if the connections can be established but you
     cannot send packets from the local node, try to set this to off
     and do an ifconfig down on the device.

   * ip-proto = numerical-ip-protocol

     Sets the protocol number to be used for the rawip protocol. This
     is a global option because all nodes must use the same protocol,
     and since there are no port numbers, you cannot easily run more
     than one gvpe instance using the same protocol, nor can you share
     the protocol with other programs.

     The default is 47 (GRE), which has a good chance of tunneling
     through firewalls (but note that gvpe's rawip protocol is not GRE
     compatible). Other common choices are 50 (IPSEC, ESP), 51 (IPSEC,
     AH), 4 (IPIP tunnels) or 98 (ENCAP, rfc1241).

     Many versions of Linux seem to have a bug that causes them to
     reorder packets for some ip protocols (GRE, ESP) but not for
     others (AH), so choose wisely (that is, use 51, AH).

   * http-proxy-host = hostname/ip

     The http-proxy-* family of options are only available if gvpe was
     compiled with the -enable-http-proxy option and enable tunneling
     of tcp connections through a http proxy server.

     http-proxy-host and http-proxy-port should specify the hostname
     and port number of the proxy server. See http-proxy-loginpw if
     your proxy requires authentication.

     Please note that gvpe will still try to resolve all hostnames in
     the configuration file, so if you are behind a proxy without
     access to a DNS server better use numerical IP addresses.

     To make best use of this option disable all protocols except TCP
     in your config file and make sure your routers (or all other
     nodes) are listening on a port that the proxy allows (443, https,
     is a common choice).

     If you have a router, connecting to it will suffice. Otherwise TCP
     must be enabled on all nodes.

     Example:

             http-proxy-host = proxy.example.com
             http-proxy-port = 3128	# 8080 is another common choice
             http-proxy-auth = schmorp:grumbeere

   * http-proxy-port = proxy-tcp-port

     The port where your proxy server listens.

   * http-proxy-auth = login:password

     The optional login and password used to authenticate to the proxy
     server, separated by a literal colon (:). Only basic
     authentication is currently supported.

   * keepalive = seconds

     Sets the keepalive probe interval in seconds (default: 60). After
     this many seconds of inactivity the daemon will start to send
     keepalive probe every 3 seconds until it receives a reply from the
     other end.  If no reply is received within 15 seconds, the peer is
     considered unreachable and the connection is closed.

   * loglevel = noise|trace|debug|info|notice|warn|error|critical

     Set the logging level. Connection established messages are logged
     at level info, notable errors are logged with error. Default is
     info.

   * mtu = bytes

     Sets the maximum MTU that should be used on outgoing packets
     (basically the MTU of the outgoing interface) The daemon will
     automatically calculate maximum overhead (e.g. UDP header size,
     encryption blocksize...) and pass this information to the if-up
     script.

     Recommended values are 1500 (ethernet), 1492 (pppoe), 1472 (pptp).

     This value must be the minimum of the MTU values of all nodes.

   * node = nickname

     Not really a config setting but introduces a node section. The
     nickname is used to select the right configuration section and
     must be passed as an argument to the gvpe daemon.

   * node-up = relative-or-absolute-path

     Sets a command (default: none) that should be called whenever a
     connection is established (even on rekeying operations). Note that
     node-up/down scripts will be run asynchronously, but execution is
     serialised, so there will only ever be one such script running.

     In addition to all the variables passed to if-up scripts, the
     following environment variables will be set (values are just
     examples):

        * DESTNODE=branch2

          The name of the remote node.

        * DESTID=2

          The node id of the remote node.

        * DESTSI=rawip/88.99.77.55:0

          The "socket info" of the target node, protocol dependent but
          usually in the format protocol/ip:port.

        * DESTIP=188.13.66.8

          The numerical IP address of the remote node (gvpe accepts
          connections from everywhere, as long as the other node can
          authenticate itself).

        * DESTPORT=655 # deprecated

          The protocol port used by the other side, if applicable.

        * STATE=up

          Node-up scripts get called with STATE=up, node-change scripts
          get called with STATE=change and node-down scripts get called
          with STATE=down.


     Here is a nontrivial example that uses nsupdate to update the name
     => ip mapping in some DNS zone:

             #!/bin/sh
             {
               echo update delete $DESTNODE.lowttl.example.net. a
               echo update add $DESTNODE.lowttl.example.net. 1 in a $DESTIP
               echo
             } | nsupdate -d -k $CONFBASE:key.example.net.

   * node-change = relative-or-absolute-path

     Same as node-change, but gets called whenever something about a
     connection changes (such as the source IP address).

   * node-down = relative-or-absolute-path

     Same as node-up, but gets called whenever a connection is lost.

   * pid-file = path

     The path to the pid file to check and create (default:
     LOCALSTATEDIR/run/gvpe.pid).

   * private-key = relative-path-to-key

     Sets the path (relative to the config directory) to the private
     key (default: hostkey). This is a printf format string so every %
     must be doubled. A single %s is replaced by the hostname, so you
     could use paths like hostkeys/%s to fetch the files at the
     location where gvpectrl puts them.

     Since only the private key file of the current node is used and
     the private key file should be kept secret per-node to avoid
     spoofing, it is not recommended to use this feature.

   * rekey = seconds

     Sets the rekeying interval in seconds (default: 3600). Connections
     are reestablished every rekey seconds, making them use a new
     encryption key.

   * nfmark = integer

     This advanced option, when set to a nonzero value (default: 0),
     tries to set the netfilter mark (or fwmark) value on all sockets
     gvpe uses to send packets.

     This can be used to make gvpe use a different set of routing
     rules. For example, on GNU/Linux, the if-up could set nfmark to
     1000 and then put all routing rules into table 99 and then use an
     ip rule to make gvpe traffic avoid that routing table, in effect
     routing normal traffic via gvpe and gvpe traffic via the normal
     system routing tables:

             ip rule add not fwmark 1000 lookup 99


4.5.2 NODE SPECIFIC SETTINGS
----------------------------

The following settings are node-specific, that is, every node can have
different settings, even within the same gvpe instance. Settings that
are set before the first node section set the defaults, settings that
are set within a node section only apply to the given node.

   * allow-direct = nodename

     Allow direct connections to this node. See deny-direct for more
     info.

   * compress = yes|true|on | no|false|off

     For the current node, this specified whether it will accept
     compressed packets, and for all other nodes, this specifies
     whether to try to compress data packets sent to this node
     (default: yes). Compression is really cheap even on slow
     computers, has no size overhead at all and will only be used when
     the other side supports compression, so enabling this is often a
     good idea.

   * connect = ondemand | never | always | disabled

     Sets the connect mode (default: always). It can be always (always
     try to establish and keep a connection to the given node), never
     (never initiate a connection to the given host, but accept
     connections), ondemand (try to establish a connection when there
     are outstanding packets in the queue and take it down after the
     keepalive interval) or disabled (node is bad, don't talk to it).

     Routers will automatically be forced to always unless they are
     disabled, to ensure all nodes can talk to each other.

   * deny-direct = nodename | *

     Deny direct connections to the specified node (or all nodes when *
     is given). Only one node can be specified, but you can use
     multiple allow-direct and deny-direct statements. This only makes
     sense in networks with routers, as routers are required for
     indirect connections.

     Sometimes, a node cannot reach some other nodes for reasons of
     network connectivity. For example, a node behind a firewall that
     only allows connections to/from a single other node in the
     network. In this case one should specify deny-direct = * and
     allow-direct = othernodename (the other node _must_ be a router
     for this to work).

     The algorithm to check whether a connection may be direct is as
     follows:

     1. Other node mentioned in an allow-direct? If yes, allow the
     connection.

     2. Other node mentioned in a deny-direct? If yes, deny direct
     connections.

     3. Allow the connection.

     That is, allow-direct takes precedence over deny-direct.

     The check is done in both directions, i.e. both nodes must allow a
     direct connection before one is attempted, so you only need to
     specify connect limitations on one node.

   * dns-domain = domain-suffix

     The DNS domain suffix that points to the DNS tunnel server for
     this node.

     The domain must point to a NS record that points to the
     _dns-hostname_, i.e.

             dns-domainname = tunnel.example.net
             dns-hostname   = tunnel-server.example.net

     Corresponds to the following DNS entries in the example.net domain:

             tunnel.example.net.         NS tunnel-server.example.net.
             tunnel-server.example.net.  A  13.13.13.13

   * dns-hostname = hostname/ip

     The address to bind the DNS tunnel socket to, similar to the
     hostname, but for the DNS tunnel protocol only. Default: 0.0.0.0,
     but that might change.

   * dns-port = port-number

     The port to bind the DNS tunnel socket to. Must be 53 on DNS
     tunnel servers.

   * enable-dns = yes|true|on | no|false|off

     See gvpe.protocol(7) for a description of the DNS transport
     protocol. Avoid this protocol if you can.

     Enable the DNS tunneling protocol on this node, either as server
     or as client. Support for this transport protocol is only
     available when gvpe was compiled using the -enable-dns option.

   * enable-icmp = yes|true|on | no|false|off

     See gvpe.protocol(7) for a description of the ICMP transport
     protocol.

     Enable the ICMP transport using ICMP packets of type icmp-type on
     this node.

   * enable-rawip = yes|true|on | no|false|off

     See gvpe.protocol(7) for a description of the RAW IP transport
     protocol.

     Enable the RAW IPv4 transport using the ip-proto protocol
     (default: no).

   * enable-tcp = yes|true|on | no|false|off

     See gvpe.protocol(7) for a description of the TCP transport
     protocol.

     Enable the TCPv4 transport using the tcp-port port (default: no).
     Support for this transport protocol is only available when gvpe
     was compiled using the -enable-tcp option.

   * enable-udp = yes|true|on | no|false|off

     See gvpe.protocol(7) for a description of the UDP transport
     protocol.

     Enable the UDPv4 transport using the udp-port port (default: no,
     unless no other protocol is enabled for a node, in which case this
     protocol is enabled automatically).

     NOTE: Please specify enable-udp = yes if you want to use it even
     though it might get switched on automatically, as some future
     version might default to another default protocol.

   * hostname = hostname | ip    [can not be defaulted]

     Forces the address of this node to be set to the given DNS
     hostname or IP address. It will be resolved before each connect
     request, so dyndns should work fine. If this setting is not
     specified and a router is available, then the router will be
     queried for the address of this node. Otherwise, the connection
     attempt will fail.

     Note that DNS resolving is done synchronously, pausing the daemon.
     If that is an issue you need to specify IP addresses.

   * icmp-type = integer

     Sets the type value to be used for outgoing (and incoming) packets
     sent via the ICMP transport.

     The default is 0 (which is echo-reply, also known as
     "ping-reply"). Other useful values include 8 (echo-request, a.k.a.
     "ping") and 11 (time-exceeded), but any 8-bit value can be used.

   * if-up-data = value

     The value specified using this directive will be passed to the
     if-up script in the environment variable IFUPDATA.

   * inherit-tos = yes|true|on | no|false|off

     Whether to inherit the TOS settings of packets sent to the tunnel
     when sending packets to this node (default: yes). If set to yes
     then outgoing tunnel packets will have the same TOS setting as the
     packets sent to the tunnel device, which is usually what you want.

   * max-retry = positive-number

     The maximum interval in seconds (default: 3600, one hour) between
     retries to establish a connection to this node. When a connection
     cannot be established, gvpe uses exponential back-off capped at
     this value. It's sometimes useful to set this to a much lower
     value (e.g. 120) on connections to routers that usually are stable
     but sometimes are down, to assure quick reconnections even after
     longer downtimes.

   * max-ttl = seconds

     Expire packets that couldn't be sent after this many seconds
     (default: 60). Gvpe will normally queue packets for a node without
     an active connection, in the hope of establishing a connection
     soon. This value specifies the maximum lifetime a packet will stay
     in the queue, if a packet gets older, it will be thrown away.

   * max-queue = positive-number>=1

     The maximum number of packets that will be queued (default: 512)
     for this node. If more packets are sent then earlier packets will
     be expired. See max-ttl, above.

   * router-priority = 0 | 1 | positive-number>=2

     Sets the router priority of the given node (default: 0, disabled).

     If some node tries to connect to another node but it doesn't have
     a hostname, it asks a router node for it's IP address. The router
     node chosen is the one with the highest priority larger than 1
     that is currently reachable. This is called a _mediated_
     connection, as the connection itself will still be direct, but it
     uses another node to mediate between the two nodes.

     The value 0 disables routing, that means if the node receives a
     packet not for itself it will not forward it but instead drop it.

     The special value 1 allows other hosts to route through the router
     host, but they will never route through it by default (i.e. the
     config file of another node needs to specify a router priority
     higher than one to choose such a node for routing).

     The idea behind this is that some hosts can, if required, bump the
     router-priority setting to higher than 1 in their local config to
     route through specific hosts. If router-priority is 0, then
     routing will be refused, so 1 serves as a "enable, but do not use
     by default" switch.

     Nodes with router-priority set to 2 or higher will always be
     forced to connect = always (unless they are disabled).

   * tcp-port = port-number

     Similar to udp-port (default: 655), but sets the TCP port number.

   * udp-port = port-number

     Sets the port number used by the UDP protocol (default: 655, not
     officially assigned by IANA!).


4.6 CONFIG DIRECTORY LAYOUT
===========================

The default (or recommended) directory layout for the config directory
is:

   * gvpe.conf

     The config file.

   * if-up

     The if-up script

   * node-up, node-down

     If used the node up or node-down scripts.

   * hostkey

     The private key (taken from hostkeys/nodename) of the current host.

   * pubkey/nodename

     The public keys of the other nodes, one file per node.



File: gvpe.info,  Node: gvpectrl,  Next: gvpe,  Prev: gvpe.conf,  Up: Top

5 gvpectrl
**********

5.1 NAME
========

gvpectrl - GNU Virtual Private Ethernet Control Program

5.2 SYNOPSIS
============

gvpectrl [*-ckgs*] [*-config=*_DIR_] [*-generate-keys*] [*-help*]
[*-kill*[*=*_SIGNAL_]] [*-show-config*] [*-version*]

5.3 DESCRIPTION
===============

This is the control program for the gvpe, the virtual private ethernet
daemon.

5.4 OPTIONS
===========

   * *-c*, *-config=*_DIR_

     Read configuration options from _DIR_.

   * *-g*, *-generate-keys*

     Generate public/private RSA key-pair and exit.

   * *-q*, *-quiet*

     Suppresses messages the author finds nonessential for scripting
     purposes.

   * *-help*

     Display short list of options.

   * *-kill*[*=*_SIGNAL_]

     Attempt to kill a running gvpectrl (optionally with the specified
     _SIGNAL_ instead of SIGTERM) and exit.

   * *-show-config*

     Show a summary of the configuration, and how gvpe interprets it.
     Can also be very useful when designing firewall scripts.

   * *-version*

     Output version information and exit.


5.5 BUGS
========

If you find any bugs, report them to gvpe@schmorp.de.


File: gvpe.info,  Node: gvpe,  Next: gvpe.protocol,  Prev: gvpectrl,  Up: Top

6 gvpe
******

6.1 NAME
========

gvpe - GNU Virtual Private Ethernet Daemon

6.2 SYNOPSIS
============

gvpe [*-cDlL*] [*-config=*_DIR_] [*-no-detach*] [*-l=*_LEVEL]_]
[*-kill*[*=*_SIGNAL_]] [*-mlock*] [*-help*] [*-version*] _NODENAME_
[_option..._]

6.3 DESCRIPTION
===============

See the gvpe(5) man page for an introduction to the gvpe suite.

   This is the manual page for gvpe, the virtual private ethernet
daemon. When started, gvpe will read it's configuration file to
determine the network topology, and other configuration information,
assuming the role of node _NODENAME_

   It will then create/connect to the tun/tap device and set up a
socket for incoming connections. Then a if-up script will be executed
to further configure the virtual network device. If that succeeds, it
will detach from the controlling terminal and continue in the
background, accepting and setting up connections to other gvpe daemons
that are part of the same virtual private ethernet.

   The optional arguments after the node name have to be of the form:

        [I<nodename>.]var=value

   If the argument has a prefix of nodename. (i.e.
laptop.enable-dns=yes) then it will be parsed after all the config
directives for that node, if not, it is parsed before the first node
directive in the config file, and can be used to set global options or
default variables.

   For example, to start gvpe in the foreground, with log-level info on
the node laptop, with TCP enabled and HTTP-Proxy host and Port set, use
this:

       gvpe -D -l info laptop \
            http-proxy-host=10.0.0.18 http-proxy-port=3128 \
            laptop.enable-tcp=yes

6.4 OPTIONS
===========

   * *-c*, *-config=*_DIR_

     Read configuration options from _DIR_

   * *-d*, *-l=*_LEVEL_

     Set logging level to _LEVEL_ (one of: noise, trace, debug, info,
     notice, warn, error, critical).

   * *-help*

     Display short list of options.

   * *-D*, *-no-detach*

     Don't fork and detach but stay in foreground and log messages to
     stderr in addition to syslog.

   * *-L*, *-mlock*

     Lock gvpe into main memory. This will prevent sensitive data like
     shared private keys to be written to the system swap
     files/partitions.

   * *-version*

     Output version information and exit.


6.5 SIGNALS
===========

   * HUP

     Closes/resets all connections, resets the retry time and will
     start connecting again (it will NOT re-read the config file). This
     is useful e.g. in a /etc/ppp/if-up script.

   * TERM

     Closes/resets all connections and exits.

   * USR1

     Dump current network status into the syslog (at loglevel notice,
     so make sure your loglevel allows this).


6.6 FILES
=========

   * /etc/gvpe/gvpe.conf

     The configuration file for gvpe.

   * /etc/gvpe/if-up

     Script which is executed as soon as the virtual network device has
     been allocated.  Purpose is to further configure that device.

   * /etc/gvpe/node-up

     Script which is executed whenever a node connects to this node.
     This can be used for example to run nsupdate.

   * /etc/gvpe/node-down

     Script which is executed whenever a connection to another node is
     lost. for example to run nsupdate.

   * /etc/gvpe/pubkey/*

     The directory containing the public keys for every node, usually
     autogenerated by executing gvpectrl -generate-keys.

   * /var/run/gvpe.pid

     The PID of the currently running gvpe is stored in this file.


6.7 BUGS
========

The cryptography in gvpe has not been thoroughly checked by many people
yet. Use it at your own risk!

   If you find any bugs, report them to gvpe@schmorp.de.


File: gvpe.info,  Node: gvpe.protocol,  Next: Simple Example,  Prev: gvpe,  Up: Top

7 gvpe.protocol
***************

7.1 The GNU-VPE Protocols
=========================

7.2 Overview
============

GVPE can make use of a number of protocols. One of them is the GNU VPE
protocol which is used to authenticate tunnels and send encrypted data
packets. This protocol is described in more detail the second part of
this document.

   The first part of this document describes the transport protocols
which are used by GVPE to send it's data packets over the network.

7.3 PART 1: Transport protocols
===============================

GVPE offers a wide range of transport protocols that can be used to
interchange data between nodes. Protocols differ in their overhead,
speed, reliability, and robustness.

   The following sections describe each transport protocol in more
detail. They are sorted by overhead/efficiency, the most efficient
transport is listed first:

7.3.1 RAW IP
------------

This protocol is the best choice, performance-wise, as the minimum
overhead per packet is only 38 bytes.

   It works by sending the VPN payload using raw IP frames (using the
protocol set by ip-proto).

   Using raw IP frames has the drawback that many firewalls block
"unknown" protocols, so this transport only works if you have full IP
connectivity between nodes.

7.3.2 ICMP
----------

This protocol offers very low overhead (minimum 42 bytes), and can
sometimes tunnel through firewalls when other protocols can not.

   It works by prepending an ICMP header with type icmp-type and a code
of 255. The default icmp-type is echo-reply, so the resulting packets
look like echo replies, which looks rather strange to network
administrators.

   This transport should only be used if other transports (i.e. raw IP)
are not available or undesirable (due to their overhead).

7.3.3 UDP
---------

This is a good general choice for the transport protocol as UDP packets
tunnel well through most firewalls and routers, and the overhead per
packet is moderate (minimum 58 bytes).

   It should be used if RAW IP is not available.

7.3.4 TCP
---------

This protocol is a very bad choice, as it not only has high overhead
(more than 60 bytes), but the transport also retries on it's own, which
leads to congestion when the link has moderate packet loss (as both the
TCP transport and the tunneled traffic will retry, increasing
congestion more and more). It also has high latency and is quite
inefficient.

   It's only useful when tunneling through firewalls that block better
protocols. If a node doesn't have direct internet access but a HTTP
proxy that supports the CONNECT method it can be used to tunnel through
a web proxy. For this to work, the tcp-port should be 443 (https), as
most proxies do not allow connections to other ports.

   It is an abuse of the usage a proxy was designed for, so make sure
you are allowed to use it for GVPE.

   This protocol also has server and client sides. If the tcp-port is
set to zero, other nodes cannot connect to this node directly. If the
tcp-port is non-zero, the node can act both as a client as well as a
server.

7.3.5 DNS
---------

*WARNING:* Parsing and generating DNS packets is rather tricky. The
code almost certainly contains buffer overflows and other, likely
exploitable, bugs. You have been warned.

   This is the worst choice of transport protocol with respect to
overhead (overhead can be 2-3 times higher than the transferred data),
and latency (which can be many seconds). Some DNS servers might not be
prepared to handle the traffic and drop or corrupt packets. The client
also has to constantly poll the server for data, so the client will
constantly create traffic even if it doesn't need to transport packets.

   In addition, the same problems as the TCP transport also plague this
protocol.

   It's only use is to tunnel through firewalls that do not allow
direct internet access. Similar to using a HTTP proxy (as the TCP
transport does), it uses a local DNS server/forwarder (given by the
dns-forw-host configuration value) as a proxy to send and receive data
as a client, and an NS record pointing to the GVPE server (as given by
the dns-hostname directive).

   The only good side of this protocol is that it can tunnel through
most firewalls mostly undetected, iff the local DNS server/forwarder is
sane (which is true for most routers, wireless LAN gateways and
nameservers).

   Fine-tuning needs to be done by editing src/vpn_dns.C directly.

7.4 PART 2: The GNU VPE protocol
================================

This section, unfortunately, is not yet finished, although the protocol
is stable (until bugs in the cryptography are found, which will likely
completely change the following description). Nevertheless, it should
give you some overview over the protocol.

7.4.1 Anatomy of a VPN packet
-----------------------------

The exact layout and field lengths of a VPN packet is determined at
compile time and doesn't change. The same structure is used for all
transport protocols, be it RAWIP or TCP.

      +------+------+--------+------+
      | HMAC | TYPE | SRCDST | DATA |
      +------+------+--------+------+

   The HMAC field is present in all packets, even if not used (e.g. in
auth request packets), in which case it is set to all zeroes. The
checksum itself is calculated over the TYPE, SRCDST and DATA fields in
all cases.

   The TYPE field is a single byte and determines the purpose of the
packet (e.g. RESET, COMPRESSED/UNCOMPRESSED DATA, PING, AUTH
REQUEST/RESPONSE, CONNECT REQUEST/INFO etc.).

   SRCDST is a three byte field which contains the source and
destination node IDs (12 bits each).

   The DATA portion differs between each packet type, naturally, and is
the only part that can be encrypted. Data packets contain more fields,
as shown:

      +------+------+--------+------+-------+------+
      | HMAC | TYPE | SRCDST | RAND | SEQNO | DATA |
      +------+------+--------+------+-------+------+

   RAND is a sequence of fully random bytes, used to increase the
entropy of the data for encryption purposes.

   SEQNO is a 32-bit sequence number. It is negotiated at every
connection initialization and starts at some random 31 bit value. VPE
currently uses a sliding window of 512 packets/sequence numbers to
detect reordering, duplication and replay attacks.

7.4.2 The authentication protocol
---------------------------------

Before nodes can exchange packets, they need to establish authenticity
of the other side and a key. Every node has a private RSA key and the
public RSA keys of all other nodes.

   A host establishes a simplex connection by sending the other node an
RSA encrypted challenge containing a random challenge (consisting of
the encryption key to use when sending packets, more random data and
PKCS1_OAEP padding) and a random 16 byte "challenge-id" (used to detect
duplicate auth packets). The destination node will respond by replying
with an (unencrypted) RIPEMD160 hash of the decrypted challenge, which
will authenticate that node. The destination node will also set the
outgoing encryption parameters as given in the packet.

   When the source node receives a correct auth reply (by verifying the
hash and the id, which will expire after 120 seconds), it will start to
accept data packets from the destination node.

   This means that a node can only initiate a simplex connection,
telling the other side the key it has to use when it sends packets. The
challenge reply is only used to set the current IP address of the other
side and protocol parameters.

   This protocol is completely symmetric, so to be able to send packets
the destination node must send a challenge in the exact same way as
already described (so, in essence, two simplex connections are created
per node pair).

7.4.3 Retrying
--------------

When there is no response to an auth request, the node will send auth
requests in bursts with an exponential back-off. After some time it
will resort to PING packets, which are very small (8 bytes + protocol
header) and lightweight (no RSA operations required). A node that
receives ping requests from an unconnected peer will respond by trying
to create a connection.

   In addition to the exponential back-off, there is a global
rate-limit on a per-IP base. It allows long bursts but will limit total
packet rate to something like one control packet every ten seconds, to
avoid accidental floods due to protocol problems (like a RSA key file
mismatch between two nodes).

   The intervals between retries are limited by the max-retry
configuration value. A node with connect = always will always retry, a
node with connect = ondemand will only try (and re-try) to connect as
long as there are packets in the queue, usually this limits the retry
period to max-ttl seconds.

   Sending packets over the VPN will reset the retry intervals as well,
which means as long as somebody is trying to send packets to a given
node, GVPE will try to connect every few seconds.

7.4.4 Routing and Protocol translation
--------------------------------------

The GVPE routing algorithm is easy: there isn't much routing to speak
of: When routing packets to another node, GVPE trues the following
options, in order:

   * If the two nodes should be able to reach each other directly
     (common protocol, port known), then GVPE will send the packet
     directly to the other node.

   * If this isn't possible (e.g. because the node doesn't have a
     hostname or known port), but the nodes speak a common protocol and
     a router is available, then GVPE will ask a router to "mediate"
     between both nodes (see below).

   * If a direct connection isn't possible (no common protocols) or
     forbidden (deny-direct) and there are any routers, then GVPE will
     try to send packets to the router with the highest priority that
     is connected already _and_ is able (as specified by the config
     file) to connect directly to the target node.

   * If no such router exists, then GVPE will simply send the packet to
     the node with the highest priority available.

   * Failing all that, the packet will be dropped.


   A host can usually declare itself unreachable directly by setting
it's port number(s) to zero. It can declare other hosts as unreachable
by using a config-file that disables all protocols for these other
hosts. Another option is to disable all protocols on that host in the
other config files.

   If two hosts cannot connect to each other because their IP
address(es) are not known (such as dial-up hosts), one side will send a
_mediated_ connection request to a router (routers must be configured
to act as routers!), which will send both the originating and the
destination host a connection info request with protocol information
and IP address of the other host (if known). Both hosts will then try
to establish a direct connection to the other peer, which is usually
possible even when both hosts are behind a NAT gateway.

   Routing via other nodes works because the SRCDST field is not
encrypted, so the router can just forward the packet to the destination
host. Since each host uses it's own private key, the router will not be
able to decrypt or encrypt packets, it will just act as a simple router
and protocol translator.


File: gvpe.info,  Node: Simple Example,  Next: Complex Example,  Prev: gvpe.protocol,  Up: Top

8 Simple Example
****************

In this example, gvpe is used to implement a simple, UDP-based ethernet
on three hosts.

   The config file (gvpe.conf) is the same on all hosts:

        enable-udp = yes     # use UDP
        udp-port = 407       # use this UDP port
        mtu = 1492           # handy for TDSL
        ifname = vpn0        # I prefer vpn0 over e.g. tap0

        node = huffy         # arbitrary node name
        hostname = 1.2.3.4   # ip address if this host

        node = welshy
        hostname = www.example.net # resolve at connection time

        node = wheelery
        # no hostname, will be determinded dynamically using router1 or router2

   gvpe will execute the if-up script on every hosts, which, for linux,
could look like this for all three hosts:

        ifconfig $IFNAME hw ether $MAC mtu $MTU
        ifconfig $IFNAME 10.0.0.$NODE
        route add -net 10.0.0.0 netmask 255.0.0.0 dev $IFNAME

   The 10.0.0.$NODE resolves to 10.0.0.1 on huffy, 10.0.0.2 on welshy
and so on. Other schemes, such as 10.$NODE.0.1 might be useful, too.

   After generating the keys (gvpectrl) and starting the daemon (gvpe
-D -l info _NODENAME_ for test purposes) the three hosts should be able
to ping each other.

   If you have an internal 10.x.x.x network (with a tighter netmask
then 255.0.0.0, e.g. 10.1.0.0 on huffy, 10.2.0.0 on welshy and so on),
you can now enable ip-forwarding and proxy-arp (or set the hosts as
default gateway), and your three hosts should forward traffic from each
network to each other.


File: gvpe.info,  Node: Complex Example,  Next: complex/gvpe.conf,  Prev: Simple Example,  Up: Top

9 Complex Example
*****************

These files are configuration files for "our" internal network.

   It is highly non-trivial, so don't use this configuration as the
basis of your network unless you know what you are doing.

   It features: around 30 hosts, many of them have additional networks
behind them and use an assortment of different tunneling protocols. The
vpn is fully routed, no arp is used at all.

   The public IP addresses of connecting nodes are automatically
registered via dns on the node ruth, using a node-up/node-down script.

   And last not least: the if-up script can generate information to be
used in firewall rules (IP-net/MAC-address pairs) so ensure packet
integrity so you can use your iptables etc. firewall to filter by IP
address only.

* Menu:

* complex/gvpe.conf:: An example gvpe configuration
* complex/if-up::     A fully-routing if-up config
* complex/node-up::   A node-up/node-down script utilizing dynds


File: gvpe.info,  Node: complex/gvpe.conf,  Next: complex/if-up,  Prev: Complex Example,  Up: Complex Example

10 complex/gvpe.conf
********************

     # sample configfile
     # the config file must be exactly(!) the same on all nodes

     rekey = 54321		# the rekeying interval
     keepalive = 300		# the keepalive interval
     on ruth keepalive = 120	# ruth is important and demands lower keepalives
     on surfer keepalive = 40
     mtu = 1492		# the mtu (minimum mtu of attached host)
     ifname = vpn0		# the tunnel interface name to use
     ifpersist = no		# the tun device should be persistent
     inherit-tos = yes	# should tunnel packets inherit tos flags?
     compress = yes		# wether compression should be used (NYI)
     connect = ondemand	# connect to this host always/never or ondemand
     router-priority = 1	# route for everybody - if necessary

     loglevel = notice	# info logs connects, notice only important messages
     on mobil loglevel = info
     on doom loglevel = info
     on ruth loglevel = info

     udp-port = 407		# the udp port to use for sending/receiving packets
     tcp-port = 443		# the tcp port to listen for connections (we use https over proxy)
     ip-proto = 50		# (ab)use the ipsec protocol as rawip
     icmp-type = 0		# (ab)use echo replies for tunneling
     enable-udp = yes	# udp is spoken almost everywhere
     enable-tcp = no		# tcp is not spoken everywhere
     enable-rawip = no	# rawip is not spoken everywhere
     enable-icmp = no	# most hosts don't bother to icmp

     # every "node =" introduces a new node in the network
     # the options following it don't set defaults but are
     # node-specific.

     # marc@lap
     node = mobil

     # marc@home
     node = doom
     enable-rawip = yes
     enable-tcp = yes

     # marc@uni
     node = ruth
     enable-rawip = yes
     enable-tcp = yes
     enable-icmp = yes
     hostname = 200.100.162.95
     connect = always
     router-priority = 30
     on ruth node-up = node-up
     on ruth node-down = node-up

     # marc@mu
     node = frank
     enable-rawip = yes
     hostname = 44.88.167.250
     router-priority = 20
     connect = always

     # nethype
     node = rain
     enable-rawip = yes
     hostname = 145.253.105.130
     router-priority = 10
     connect = always

     # marco@home
     node = marco
     enable-rawip = yes

     # stefan@ka
     node = wappla
     connect = never

     # stefan@lap
     node = stefan
     udp-port = 408
     connect = never

     # paul@wg
     node = n8geil
     on ruth enable-icmp = yes
     on n8geil enable-icmp = yes
     enable-udp = no

     # paul@lap
     node = syrr

     # paul@lu
     node = donomos

     # marco@hn
     node = core

     # elmex@home
     node = elmex
     enable-rawip = yes
     hostname = 100.251.143.181

     # stefan@kwc.at
     node = fwkw
     connect = never
     on stefan connect = always
     on wappla connect = always
     hostname = 182.73.81.146

     # elmex@home
     node = jungfrau
     enable-rawip = yes

     # uni main router
     node = surfer
     enable-rawip = yes
     enable-tcp = no
     enable-icmp = yes
     hostname = 200.100.162.79
     connect = always
     router-priority = 40

     # jkneer@marvin
     node = marvin
     enable-rawip = yes
     enable-udp = no

     # jkneer@entrophy
     node = entrophy
     enable-udp = no
     enable-tcp = yes

     # mr. primitive
     node = voyager
     enable-udp = no
     enable-tcp = no
     on voyager enable-tcp = yes
     on voyager enable-udp = yes

     # v-server (barbados.dn-systems.de)
     #node = vserver
     #enable-udp = yes
     #hostname = 193.108.181.74


File: gvpe.info,  Node: complex/if-up,  Next: complex/node-up,  Prev: complex/gvpe.conf,  Up: Complex Example

11 complex/if-up
****************

     #!/bin/bash

     # Some environment variables will be set:
     #
     # CONFBASE=/etc/vpe	# the configuration directory prefix
     # IFNAME=vpn0		# the network interface (ifname)
     # MAC=fe:fd:80:00:00:01	# the mac-address to use for the interface
     # NODENAME=cerebro	# the selected nodename (-n switch)
     # NODEID=1		# the numerical node id
     # MTU=1436		# the tunnel packet overhead (set mtu to 1500-$OVERHEAD)

     # this if-up script is rather full-featured, and is used to
     # generate a fully-routed (no arp traffic) vpn. the main portion
     # consists of "ipn" calls (see below).

     # some hosts require additional specific configuration, this is handled
     # using if statements near the end of the script.

     # with the --fw switch, outputs mac/net pairs for your firewall use:
     # if-up --fw | while read mac net; do
     #   iptables -t filter -A INPUT -i vpn0 -p all -m mac --mac-source \! $mac -s $net -j DROP
     # done

     ipn() {
        local id="$1"; shift
        local mac=fe:fd:80:00:00:$(printf "%02x" $id)
        if [ -n "$FW" ]; then
           for net in "$@"; do
              echo "$mac $net"
           done
        else
           local ip="$1"; shift
           if [ "$id" == $NODEID ]; then
              [ -n "$ADDR_ONLY" ] && ip addr add $ip broadcast 10.255.255.255 dev $IFNAME
           elif [ -z "$ADDR_ONLY" ]; then
              ip neighbour add $ip lladdr $mac nud permanent dev $IFNAME
              for route in "$@"; do
                 ip route add $route via $ip dev vpn0
              done
           fi
        fi
     }

     ipns() {
        # this contains the generic routing information for the vpn
        # each call to ipn has the following parameters:
        # ipn <node-id> <gateway-ip> [<route> ...]
        # the second line (ipn 2) means:
        # the second node (doom in the config file) has the ip address 10.0.0.5,
        # which is the gateway for the 10.0/28 network and three additional ip
        # addresses

        ipn  1 10.0.0.20
        ipn  2 10.0.0.5  10.0.0.0/28 #200.100.162.92 200.100.162.93 100.99.218.222
        ipn  3 10.0.0.17
        ipn  4 10.0.0.18
        ipn  5 10.0.0.19 10.3.0.0/16
        ipn  6 10.0.0.21 10.0.2.0/26 #200.100.162.17
        ipn  7 10.0.0.22 10.1.2.0/24 # wappla, off
        ipn  8 10.0.0.23 # stefan, off
        ipn  9 10.0.0.24 10.13.0.0/16
        ipn 10 10.0.0.25
        ipn 11 10.0.0.26
        ipn 12 10.0.0.27 10.0.2.64/26
        ipn 13 10.0.0.28 10.0.3.0/24
        ipn 14 10.0.0.29 10.1.1.0/24 # fwkw, off
        # mind the gateway ip gap
        ipn 15 10.9.0.30 10.0.4.0/24
        ipn 16 10.9.0.31
        ipn 17 10.9.0.32 10.42.0.0/16
        ipn 18 10.9.0.33
        ipn 19 10.9.0.34
        #ipn 20 10.9.0.35
     }

     if [ "$1" == "--fw" ]; then
        FW=1

        ipns
     else
        exec >/var/log/vpe.if-up 2>&1
        set -x

        [ $NODENAME = "ruth"    ] && ip link set $IFNAME down # hack

        # first set the link up and initialize the interface ip
        # address.
        ip link set $IFNAME address $MAC
        ip link set $IFNAME mtu $MTU up
        ADDR_ONLY=1 ipns # set addr only

        # now initialize the main vpn routes (10.0/8)
        # the second route is a hack to to reach some funnily-connected
        # machines.
        ip route add 10.0.0.0/8 dev $IFNAME
        ip route add 10.0.0.0/27 dev $IFNAME

        ipns # set the interface routes

        # now for something completely different, ehr, something not
        # easily doable with ipn, namely some extra specific highly complicated
        # and non-regular setups for some machines.
        if [ $NODENAME = doom ]; then
           ip addr add 200.100.162.92 dev $IFNAME
           ip route add 200.100.0.0/16 via 10.0.0.17 dev $IFNAME
           ip route flush table 101
           ip route add table 101 default src 200.100.162.92 via 10.0.0.17 dev $IFNAME

           ip addr add 100.99.218.222 dev $IFNAME
           ip route add 100.99.218.192/27 via 10.0.0.19 dev $IFNAME
           ip route flush table 103
           ip route add table 103 default src 100.99.218.222 via 10.0.0.19

        elif [ $NODENAME = marco ]; then
           ip addr add 200.100.162.17 dev $IFNAME

           for addr in 79 89 90 91 92 93 94 95; do
              ip route add 200.100.162.$addr dev ppp0
           done
           ip route add 200.100.76.0/23 dev ppp0
           ip route add src 200.100.162.17 200.100.0.0/16 via 10.0.0.17 dev $IFNAME

        elif [ $NODENAME = ruth ]; then
           ip route add 200.100.162.17 via 10.0.0.21 dev vpn0
           ip route add 200.100.162.92 via 10.0.0.5 dev vpn0
           ip route add 200.100.162.93 via 10.0.0.5 dev vpn0

        fi

        # and this is the second part of the 10.0/27 hack. don't ask.
        [ $NODENAME != fwkw ] && ip route add 10.0.0.0/24 via 10.0.0.29 dev $IFNAME
     fi


File: gvpe.info,  Node: complex/node-up,  Next: Index,  Prev: complex/if-up,  Up: Complex Example

12 complex/node-up
******************

     #!/bin/sh

     # Some environment variables will be set (in addition the ones
     # set in if-up, too):
     #
     # DESTNODE=doom		# others nodename
     # DESTID=5		# others node id
     # DESTIP=188.13.66.8	# others ip
     # DESTPORT=407		# others port
     # STATE=up/down		# node-up gets UP, node-down script gets DOWN

     if [ $STATE = up ]; then
        {
          echo update delete $DESTNODE.lowttl.example.com. a
          echo update delete $DESTNODE-last.lowttl.example.com. a
          echo update add $DESTNODE.lowttl.example.com. 1 in a $DESTIP
          echo update add $DESTNODE-last.lowttl.example.com. 1 in a $DESTIP
          echo
        } | nsupdate -d -k $CONFBASE:marc.example.net.
     else
        {
          echo update delete $DESTNODE.lowttl.example.com. a
          echo update delete $DESTNODE-last.lowttl.example.com. a
          echo update add $DESTNODE-last.lowttl.example.com. 1 in a $DESTIP
          echo
        } | nsupdate -d -k $CONFBASE:marc.example.net.
     fi


File: gvpe.info,  Node: Index,  Prev: complex/node-up,  Up: Top

13 Index
********

 [index ]
* Menu:

* allow-direct:                          gvpe.conf.           (line 436)
* compress:                              gvpe.conf.           (line 441)
* CONFBASE:                              gvpe.conf.           (line 157)
* connect:                               gvpe.conf.           (line 451)
* deny-direct:                           gvpe.conf.           (line 463)
* DESTID:                                gvpe.conf.           (line 344)
* DESTIP:                                gvpe.conf.           (line 353)
* DESTNODE:                              gvpe.conf.           (line 340)
* DESTPORT:                              gvpe.conf.           (line 359)
* DESTSI:                                gvpe.conf.           (line 348)
* dns-domain:                            gvpe.conf.           (line 495)
* dns-forw-host:                         gvpe.conf.           (line  85)
* dns-forw-port:                         gvpe.conf.           (line  90)
* dns-hostname:                          gvpe.conf.           (line 511)
* dns-max-outstanding:                   gvpe.conf.           (line  95)
* dns-overlap-factor:                    gvpe.conf.           (line 105)
* dns-port:                              gvpe.conf.           (line 517)
* dns-send-interval:                     gvpe.conf.           (line 121)
* dns-timeout-factor:                    gvpe.conf.           (line 133)
* enable-dns:                            gvpe.conf.           (line 522)
* enable-icmp:                           gvpe.conf.           (line 531)
* enable-rawip:                          gvpe.conf.           (line 539)
* enable-tcp:                            gvpe.conf.           (line 547)
* enable-udp:                            gvpe.conf.           (line 556)
* hostname:                              gvpe.conf.           (line 569)
* http-proxy-auth:                       gvpe.conf.           (line 291)
* http-proxy-host:                       gvpe.conf.           (line 259)
* http-proxy-port:                       gvpe.conf.           (line 287)
* icmp-type:                             gvpe.conf.           (line 581)
* if-up:                                 gvpe.conf.           (line 148)
* if-up-data:                            gvpe.conf.           (line 590)
* ifname:                                gvpe.conf.           (line 228)
* IFNAME:                                gvpe.conf.           (line 161)
* ifpersist:                             gvpe.conf.           (line 233)
* IFSUBTYPE:                             gvpe.conf.           (line 167)
* IFTYPE:                                gvpe.conf.           (line 165)
* IFUPDATA:                              gvpe.conf.           (line 188)
* inherit-tos:                           gvpe.conf.           (line 595)
* ip-proto:                              gvpe.conf.           (line 242)
* keepalive:                             gvpe.conf.           (line 297)
* loglevel:                              gvpe.conf.           (line 305)
* MAC:                                   gvpe.conf.           (line 192)
* max-queue:                             gvpe.conf.           (line 620)
* max-retry:                             gvpe.conf.           (line 602)
* max-ttl:                               gvpe.conf.           (line 612)
* mtu:                                   gvpe.conf.           (line 311)
* MTU:                                   gvpe.conf.           (line 174)
* nfmark:                                gvpe.conf.           (line 412)
* node:                                  gvpe.conf.           (line 323)
* node-change:                           gvpe.conf.           (line 380)
* node-down:                             gvpe.conf.           (line 385)
* node-up:                               gvpe.conf.           (line 329)
* NODEID:                                gvpe.conf.           (line 204)
* NODENAME:                              gvpe.conf.           (line 200)
* NODES:                                 gvpe.conf.           (line 180)
* pid-file:                              gvpe.conf.           (line 389)
* private-key:                           gvpe.conf.           (line 394)
* rekey:                                 gvpe.conf.           (line 406)
* router-priority:                       gvpe.conf.           (line 626)
* STATE:                                 gvpe.conf.           (line 363)
* tcp-port:                              gvpe.conf.           (line 654)
* udp-port:                              gvpe.conf.           (line 658)



Tag Table:
Node: Top744
Node: Overview1769
Node: OS Dependencies12167
Node: gvpe.conf19341
Node: gvpectrl44377
Node: gvpe45582
Node: gvpe.protocol49317
Node: Simple Example60636
Node: Complex Example62280
Node: complex/gvpe.conf63336
Node: complex/if-up67021
Node: complex/node-up72092
Node: Index73252

End Tag Table
